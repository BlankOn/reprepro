<html><head>
<title>reprepro manual</title>
<!-- some style elements stolen from or inspired by bugs.debian.org /-->
<style>
<!--
html { color: #000; background: #fefefe; font-family: serif; margin: 1em; border: 0; padding: 0; line-height: 120%; }
body { margin: 0; border: 0; padding: 0; }
pre { text-align: left; border: #f0f0f0 1px solid;  padding: 1px;}
h1, h2, h3 { text-align: left; font-family: sans-serif; background-color: #f0f0ff; color: #3c3c3c; border: #a7a7a7 1px solid;  padding: 10px;}
h1 { font-size: 180%; line-height: 150%; }
h2 { font-size: 150% }
h3 { font-size: 100% }
ul.dir { list-style-type: disc; }
ul { list-style-type: square; }
dt.dir, dt.file, dt.symlink { font-weight:bold; font-family: sans-serif; }
/-->
</style>
</head>
<body>
<h1>reprepro manual</h1>
This manual documents reprepro, a tool to generate and administer
Debian package repositories.
<br>
Other useful resources:
<ul>
<li> the <a href="http://mirrorer.alioth.debian.org/">homepage</a> of  reprepro.</li>
<li> <a href="file://localhost/usr/share/doc/reprepro/">local directory</a> with documentation and examples, if you have reprepro installed.</li>
<li> the <a href="http://alioth.debian.org/plugins/scmcvs/cvsweb.php/~checkout~/mirrorer/docs/FAQ?rev=HEAD;content-type=text%2Fplain;cvsroot=mirrorer">Frequently Asked Questions</a></li>
</ul>
<h2>Table of contents</h2>
Sections of this document:
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#firststeps">First steps</a></li>
<li><a href="#dirbasics">Repository basics</a></li>
<li><a href="#localpackages">Local packages</a> (TODO)</li>
<li><a href="#incoming">Incoming directories</a> (TODO)</li>
<li><a href="#morroring">Mirroring</a> (TODO)</li>
<li><a href="#signing">Signing</a> (TODO)</li>
<li><a href="#propagation">Propagation of packages</a> (TODO)</li>
<li><a href="#snapshosts">Snapshots</a> (TODO)</li>
<li><a href="#tracking">Source package tracking</a> (TODO)</li>
<li><a href="#recovery">Disaster recovery</a> (TODO)</li>
<li><a href="#counterindications">What reprepro cannot do</a></li>
</ul>
<h2><a name="introduction">Introduction</a></h2>
<h3>What reprepro does</h3>
Reprepro is a tool to take care of a repository of Debian packages
(<tt>.dsc</tt>,<tt>.deb</tt> and <tt>.udeb</tt>).
It installs them to the proper places, generates indices of packages
(<tt>Packages</tt> and <tt>Sources</tt> and their compressed variants)
and of index files (<tt>Release</tt> and optionally <tt>Release.gpg</tt>),
so tools like <tt>apt</tt> know what is available and where to get it from.
It will keep track which file belongs to where and remove files no longer
needed (unless told to not do so).
It can also make (partial) partial mirrors of remote repositories,
including merging multiple sources and
automatically (if explicitly requested) removing packages no longer available
in the source.
And many other things (sometimes I fear it got a few features too much).
<h3>What reprepro needs</h3>
It needs some libraries (<tt>zlib</tt>, <tt>libgpgme</tt>, <tt>libdb</tt> (Version 3, 4.3 or 4.4)) and can be compiled with some more for additional features (<tt>libarchive</tt>,
<tt>libbz2</tt>).
Otherwise it only needs
<tt>apt</tt>'s methods (only when downloading stuff),
<tt>gpg</tt> (only when signing or checking signatures),
and if compiled without <tt>libarchive</tt> it needs <tt>tar</tt> and <tt>ar</tt> installed.
<br>
If you tell reprepro to call scripts for you, you will of course need the interpreters for these scripts:
The included example to generate pdiff files needs python. The example to extract
changelogs needs dpkg-source.
<h3>What this manual aims to do</h3>
This manual aims to give some overview over the most important features,
so people can use them and so that I do not implement something a second
time because I forgot support is already there.
For a full reference of all possible commands and config options take a
look at the man page, as this manual might miss some of the more obscure
options.
<h2><a name="firststeps">First steps</a></h2>
<h3>generate a repository with local packages</h3>
<ul>
<li>Choose a directory (or create it).</li>
<li>Create a subdirectory called <tt>conf</tt> in there.</li>
<li>In the <tt>conf/</tt> subdirectory create a file called <tt>distributions</tt>,
with content like:
<pre>
Codename: mystuff
Components: main bad
Architectures: sparc i386 source
</pre>
or with content like:
<pre>
Codename: andy
Suite: rusty
Components: main bad
Architectures: sparc i386 source
Origin: myorg
Version: 20.3
Description: my first little repository
</pre>
(Multiple distributions are separated by empty lines, Origin, Version and Description
are just copied to the generated Release files, more things controlling reprepro can
appear which are described later).
</li>
<li>If your <tt>conf/distributions</tt> file contained a <tt>Suite:</tt> and you
are to lazy to generate the symlinks yourself, call:
<pre>
reprepro -b $YOURBASEDIR createsymlinks
</pre>
</li>
<li>Include some package, like:
<pre>
reprepro -b $YOURBASEDIR include mypackage.changes
</pre>
or:
<pre>
reprepro -b $YOURBASEDIR includedeb mypackage.deb
</pre>
</li>
<li>Take a look at at the generated <tt>pool</tt> and <tt>dists</tt>
directories. They contain everything needed to apt-get from.
Tell apt to include it by adding the following to your <tt>sources.list</tt>:
<pre>
deb file:///$YOURBASEDIR mystuff main bad
</pre>
or make it available via http or ftp and do the same <tt>http://</tt> or <tt>ftp://</tt> source.</li>
</ul>
<h3>mirroring packages from other repositories</h3>
This example shows how to generate a mirror of a single architecture with
all packages of etch plus security updates:
<ul>
<li>Choose a directory (or create it).</li>
<li>Create a subdirectory called <tt>conf</tt> in there (if not already existent).</li>
<li>In the <tt>conf/</tt> subdirectory create a file called <tt>distributions</tt>,
with content like (or add to that file after an empty line):
<pre>
Origin: Debian
Label: Debian
Suite: stable
Version: 4.0
Codename: etch
Architectures: i386
Components: main
Description: Debian 4.0 etch + security updates
Updates: - debian security
Logfile: logfile
</pre>
Actually only <tt>Codename</tt>, <tt>Components</tt>, <tt>Architecture</tt> and <tt>Update</tt> is needed, the rest is just information for clients.
The <tt>Updates</tt> line tells to delete everything no longer available (<tt>-</tt>),
then add the <tt>debian</tt> and <tt>security</tt> rules, which still have to be defined:
</li>
<li>In the <tt>conf/</tt> subdirectory create a file called <tt>updates</tt>,
with content like (or add to that file after an empty line:):
or with content like:
<pre>
Name: security
Method: http://security.debian.org/debian-security
Fallback: ftp://klecker.debian.org/debian-security
Suite: */updates
VerifyRelease: A99951DAF9BB569BDB50AD90A70DAF536070D3A1|7EA391D72477203B58C04FBCB5D0C804ADB11277
Architectures: i386
Components: main
UDebComponents: none

Name: debian
Method: http://ftp2.de.debian.org/debian
Config: Acquire::Http::Proxy=http://proxy.myorg.de:8080
VerifyRelease: A99951DAF9BB569BDB50AD90A70DAF536070D3A1|7EA391D72477203B58C04FBCB5D0C804ADB11277
</pre>
(If there are no Architecture, Components or UDebComponents, it will try all the distribution to update has. Fallback means a URL to try when the first cannot offer some file).
</li>
<li>Tell reprepro to update:
<pre>
reprepro -b $YOURBASEDIR update etch
</pre>
</li>
<li>Take a look at at the generated <tt>pool</tt> and <tt>dists</tt>
directories. They contain everything needed to apt-get from.
Tell apt to include it by adding the following to your <tt>sources.list</tt>:
<pre>
deb file:///$YOURBASEDIR etch main
</pre>
or make it available via http or ftp.</li>
</ul>
<h2><a name="dirbasics">Repository basics</a></h2>
An <tt>apt-get</tt>able repository of Debian packages consists of two parts:
the index files describing what is available and where it is and the actual
Debian binary (<tt class="suffix">.deb</tt>),
installer binary (<tt class="suffix">.deb</tt>),
and source (<tt class="suffix">.dsc</tt> together with
<tt class="suffix">.tar.gz</tt> or
<tt class="suffix">.orig.tar.gz</tt> and
<tt class="suffix">.diff.gz</tt>) packages.
<br>
While you do not know how these look like to use reprepro, it's always a good
idea to know what you are creating.
<h3>Index files</h3>
All index files are in subdirectories of a directory called
<tt class="dirname">dists</tt>. Apt is very decided what names those should
have, including the name of <tt class="dirname">dists</tt>.
Including all optional and extensional files, the hierarchy looks like this:

<dl class="dir">
<dt class="dir">dists</dt><dd>
	<dl class="dir">
	<dt class="dir">CODENAME</dt><dd>
Each distribution has it's own subdirectory here, named by it's codename.
		<dl class="dir">
		<dt class="file">Release</dt><dd>
This file describes what distribution this is and the checksums of
all index files included.
		</dd>
		<dt class="file">Release.gpg</dt><dd>
This is the optional detached gpg signature of the Release file.
To generate it, use the <tt class="config">SignWith</tt> header in
the distribution declaration:
<pre class="config">
SignWith: yes
</pre>
If the key you specified ("<tt>yes</tt>" means the first libgpgme finds) needs
a passphrase make sure <a href="http://packages.debian.org/gpg-agent">gpg-agent</a>
is running.
		</dd>
		<dt class="file">Contents-ARCHITECTURE.gz</dt><dd>
This optional file lists all files and which packages they belong to.
It's downloaded and used by tools like
<a href="http://packages.debian.org/apt-file">apt-file</a>
to allow users to determine which package to install to get a specific file.
<br>
To activate generating of these files by reprepro, you need a <tt>Contents</tt>
header in your distribution declaration, like:
<pre class="config">
Contents: 1
</pre>
Or if you want to include only udebs but no debs and only have the file uncompressed
and bzip2ed but not gzipped, and only for some architecture, use:
<pre class="config">
Contents: 1 udebs nodebs . .bz2
ContentsArchitectures: ia64
</pre>
		</dd>
		<dt class="dir">COMPONENT1</dt><dd>
Each component has it's own subdirectory here. They can be named whatever users
can be bothered to write into their <tt class="filename">sources.list</tt>, but
things like <tt>main</tt>, <tt>non-free</tt> and <tt>contrib</tt> are common.
But funny names like <tt>bad</tt> or <tt>universe</tt> are just as possible.
			<dl class="dir">
			<dt class="dir">source</dt><dd>
If this distribution supports sources, this directory lists which source
packages are available in this component.
				<dl class="dir">
				<dt class="file">Release</dt><dd>
This file contains a copy of those information about the distribution
applicable to this directory.
				</dd>
				<dt class="file">Sources</dt>
				<dt class="file">Sources.gz</dt>
				<dt class="file">Sources.bz2</dt><dd>
These files contain the actual description of the source Packages. By default
only the <tt class="suffix">.gz</tt> file created, to create all three add the
following to the declarations of the distributions:
<pre class="config">
DscIndices Sources Release . .gz .bz2
</pre>
That header can also be used to name those files differently, but then apt
will no longer find them...
				</dd>
				<dt class="dir">Sources.diff</dt><dd>
This optional directory contains diffs, so that only parts of the index
file must be downloaded if it changed. While reprepro cannot generate these
so-called <tt>pdiff</tt>s itself, it ships with an example python script it
can call to generate those.
				</dd>
				</dl>
			</dd>
			</dl>
			<dl class="dir">
			<dt class="dir">binary-ARCHITECTURE</dt><dd>
Each architecture has its own directory in each component.
				<dl class="dir">
				<dt class="file">Release</dt><dd>
This file contains a copy of those information about the distribution
applicable to this directory.
				</dd>
				<dt class="file">Packages</dt>
				<dt class="file">Packages.gz</dt>
				<dt class="file">Packages.bz2</dt><dd>
These files contain the actual description of the binary Packages. By default
only the uncompressed and <tt class="suffix">.gz</tt> files are created.
To create all three, add the following to the declarations of the distributions:
<pre class="config">
DebIndices Packages Release . .gz .bz2
</pre>
That header can also be used to name those files differently, but then apt
will no longer find them...
				</dd>
				<dt class="dir">Packages.diff</dt><dd>
This optional directory contains diffs, so that only parts of the index
file must be downloaded if it changed. While reprepro cannot generate these
so-called <tt>pdiff</tt>s itself, it ships with an example python script it
can call to generate those.
				</dd>
				</dl>
			</dd>
			<dl class="dir">
			<dt class="dir">debian-installer</dt><dd>
This directory contains information about the <tt class="suffix">.udeb</tt>
modules for the <a href="http://www.debian.org/devel/debian-installer/">Debian-Installer</a>.
Those are actually just a very stripped down form of normal <tt class="suffix">.deb</tt>
packages and this the hierarchy looks very similar:

				<dl class="dir">
				<dt class="dir">binary-ARCHITECTURE</dt><dd>
					<dl class="dir">
					<dt class="file">Packages</dt>
					<dt class="file">Packages.gz</dt>
					</dl>
				</dd>
				</dl>
			</dd>
			</dl>
		</dd>
		<dt class="dir">COMPONENT2</dt><dd>
There is one dir for every component. All look just the same.
		</dd>
		</dl>
	</dd>
	<dt class="symlink">SUITE -> CODENAME</dt><dd>
To allow accessing distribution by function instead of by name, there are often
symlinks from suite to codenames. That way users can write
<pre class="config">
deb http://some.domain.tld/debian SUITE COMPONENT1 COMPONENT2
</pre>
instead of
<pre class="config">
deb http://some.domain.tld/debian CODENAME COMPONENT1 COMPONENT2
</pre>
in their <tt class="filename">/etc/apt/sources.list</tt> and totally get
surprised by getting something new after a release.
	</dd>
	</dl>
</dd>
</dl>
<h3>Package pool</h3>
While the index files have a required filename, the actual files
are given just as relative path to the base directory you specify
in your sources list. That means apt can get them no matter what
scheme is used to place them. The classical way Debian used till
woody was to just put them in subdirectories of the
<tt class="dir">binary-ARCHITECTURE</tt> directories, with the exception
of the architecture-independent packages, which were put into a
artificial <tt class="dir">binary-all</tt> directory. This was replaced
for the official repository with package pools, which reprepro also uses.
(Actually reprepro stores everything in pool a bit longer than the official
repositories, that's why it recalculates all filenames without exception).
<br>
In a package pool, all package files of all distributions in that repository
are stored in a common directory hierarchy starting with <tt class="dir">pool/</tt>,
only separated by the component they belong to and the source package name.
As everything this has disadvantages and advantages:
<ul><li>disadvantages
	<ul><li>different files in different distributions must have different filenames
	</li><li>it's impossible to determine which distribution a file belongs to by path and filename (think mirroring)
	</li><li>packages can no longer be grouped together in common subdirectories by having similar functions
	</li></ul>
</li><li>advantages
	<ul><li>the extremely confusing situation of having differently build packages with the same version if different distributions gets impossible by design.
	</li><li>the source (well, if it exists) is in the same directory as the binaries generated from it
	</li><li>same files in different distributions need disk-space and bandwidth only once
	</li><li>each package can be found only knowing component and sourcename
	</li></ul>
</li></ul>
Now let's look at the actual structure of a pool (there is currently no difference
between the pool structure of official Debian repositories and those generated by
reprepro):

<dl class="dir">
<dt class="dir">pool</dt><dd>
	The directory all this resides is is normally called <tt class="dir">pool</tt>.
	That's nowhere hard coded in apt but that only looks at the relative
	directory names in the index files. But there is also no reason to name
	it differently.
	<dl class="dir">
	<dt class="dir">COMPONENT1</dt><dd>
Each component has it's own subdirectory here.
They can be named whatever users
can be bothered to write into their <tt class="filename">sources.list</tt>, but
things like <tt>main</tt>, <tt>non-free</tt> and <tt>contrib</tt> are common.
But funny names like <tt>bad</tt> or <tt>universe</tt> are just as possible.
		<dl class="dir">
		<dt class="dir">a</dt><dd>
As there are really many different source packages,
the directory would be too full when all put here.
So they are separated in different directories.
Source packages starting with <tt class="constant">lib</tt> are put into a
directory named after the first four letters of the source name.
Everything else is put in a directory having the first letter as name.
			<dl class="dir">
			<dt class="dir">asource</dt><dd>
Then the source package name follows.
So this directory <tt class="dir">pool/COMPONENT1/a/asource/</tt> would contain
all files of different versions of the hypothetical package <tt class="constant">asource</tt>.
				<dl class="dir">
				<dt class="dir">asource</dt><dd>
				<dt class="file">a-source_version.dsc</dt>
				<dt>a-source_version.tar.gz</dt><dd>
The actual source package consists of its description file (<tt class="suffix">.dsc</tt>)
and the files references by that.
				</dd>
				<dt class="file">binary_version_ARCH1deb</dt>
				<dt class="file">binary_version_ARCH2.deb</dt>
				<dt class="file">binary2_version_all.deb</dt><dd>
				<dt class="file">di-module_version_ARCH1.udeb</dt><dd>
Binary packages are stored here to.
So to know where a binary package is stored you need to know what its source package
name is.
				</dd>
				</dl>
			</dd>
			</dl>
		</dd>
		<dt class="dir">liba</dt><dd>
As described before packages starting with <tt class="constant">lib</tt> are not stored
in <tt class="dir">l</tt> but get a bit more context.
		</dd>
		</dl>
	</dd>
	<dt class="dir">COMPONENT2</dt><dd>
There is one dir for every component. All look just the same.
	</dd>
	</dl>
</dd></dl>
As said before, you don't need to know this hierarchy in normal operation.
reprepro will put everything to where it belong, keep account what is there
and needed by what distribution or snapshot, and delete files no longer needed.
(Unless told otherwise or when you are using the low-level commands).
<h2><a name="localpackages">Local packages</a></h2>
TO BE DOCUMENTED
<h2><a name="incoming">Incoming directories</a></h2>
TO BE DOCUMENTED
<h2><a name="morroring">Mirroring</a></h2>
TO BE DOCUMENTED
<h2><a name="signing">Signing</a></h2>
TO BE DOCUMENTED
<h2><a name="propagation">Propagation of packages</a></h2>
You can copy packages between distributions using the pull and copypkg
commands.<br>
TO BE DOCUMENTED
<h2><a name="snapshosts">Snapshots</a></h2>
There is a gensnapshot command.<br>
TO BE DOCUMENTED
<h2><a name="tracking">Source package tracking</a></h2>
TO BE DOCUMENTED
<h2><a name="recovery">Disaster recovery</a></h2>
TO BE DOCUMENTED (see the recovery file until then)
<h2><a name="counterindications">What reprepro cannot do</a></h2>
There are some things reprepro does not do:
<dl><dt>Verbatim mirroring</dt><dd>
Reprepro aims to put all files into a coherent <tt>pool/</tt> hierarchy.
Thus it cannot guarantee that files will have the same relatives path as in the
original repository (especially if those have no pool).
It also creates the index files from its own indices.
While this leads to a tidy repository and possible savings of disk-space, the
signatures of the repositories you mirror cannot be used to authenticate the mirror,
but you will have to sign (or tell reprepro to sign for you) the result.
While this is perfect when you only mirror some parts or specific packages or
also have local packages that need local signing anyway, reprepro is no suitable tool
for creating a full mirror that can be authenticated without adding the key of this
repository.
</dd>
<dt>Placing your files on your own</dt><dd>
Reprepro does all the calculation of filenames to save files as,
bookkeeping what files are there and what are needed and so on.
This cannot be switched off or disabled.
You can place files where reprepro will expect them and reprepro will use
them if their md5sum matches.
But reprepro is not suited if you want those files outside of a pool or in
places reprepro does not consider their canonical ones.
</dd>
<dt>Having different files with the same name</dt><dd>
take a look in the <a href="http://alioth.debian.org/plugins/scmcvs/cvsweb.php/~checkout~/mirrorer/docs/FAQ?rev=HEAD;content-type=text%2Fplain;cvsroot=mirrorer">FAQ</a> (currently question 1.2) why and how to avoid the problem.
</dd>
</dl>
</body>
</html>
